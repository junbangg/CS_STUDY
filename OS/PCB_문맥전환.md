# Process Control Block(PCB)

### 한 문장으로
  > 운영체제가 프로세스를 실행하는 데 필요한 각종 중요한 정보를 보관하는 자료구조.
  
## 기본 개념
  * 프로세스의 상태 정보를 저장하는 자료구조이다.
  * 프로세스 생성 시 프로세스 고유의 PCB를 운영체제에서 하나씩 할당해 준다.
  * 프로세스가 실행이 완료되면 폐기된다.
  * 주기억장치에 유지된다.
  
## PCB의 역할
  * 프로세스의 상태에는 몇가지가 있을까?
    - 멈춰있다. 동작한다. 2가지의 상태만 있다면 PCB의 역할은 크게 중요하지 않을지도 모른다.
    - 생성중인 프로세스, 실행중인 프로세스, 입출력을 기다리는 프로세스, CPU를 기다리는 프로세스 등, 다양한 상태의 프로세스가 있다.
  * 운영체제가 다양한 상태를 갖고있는 여러개의 프로세스를 동시에 관리하게 해주는 것이 PCB 이다.
    
## PCB의 구성
![PCB](https://user-images.githubusercontent.com/33091784/135414596-8376f78f-12b1-4e02-9bca-ab07e6d607b2.png)
1. Pointer(포인터)
    > 프로세스의 준비 상태나 대기 상태는 큐(Queue)로 운영되는데, PCB를 연결하여 큐를 구현할 때 포인터를 사용한다.
2. Process State(프로세스 상태)
    > 프로세스의 현재 상태를 저장한다
    - new: 생성중인 상태
    - running: 실행중인 상태
    - waiting: 이벤트(I/O 완료) 가 일어나기를 기다리는 상태
    - ready: CPU 할당을 기다리는 상태
    - terminated: 종료
    - 보류 대기 / 보류 준비 상태
3. Process Number(프로세스 구분자)
    > 운영체제 내에 있는 다양한 프로세스를 구분하기 위한 고유 식별자(pid)를 저장한다.
4. Program Counter(프로그램 카운터)
    > 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터 값을 저장한다.
    - CPU가 하나의 프로세스를 잠시 중단하고, 다른 프로세스를 실행할 때, 기존 프로세스가 어디까지 실행됐는지 기억하기 위함.
5. CPU Scheduling Information (프로세스 우선순위, 스케쥴링 포인터)
    > 모든 프로세스는 우선순위가 다르게 할당되어 있기 때문에, 스케쥴링을 위해 우선순위  PCB에 저장한다.
    - 에를 들어, 사용자 프로세스보다 커널 프로세스가 우선순위가 높고, 사용자 프로세스끼리도 우선순위가 다를 수 있다.
6. 각종 레지스터 정보
    > CPU가 프로세스 간의 전환을 할 때, 기존 CPU의 상태(CPU 레지스터의 정보)를 저장하는 곳.
    * CPU레지스터란?: CPU 가 동작하기 위해서 필요한 정보를 저장하는 곳.
7. 메모리 관리 정보
    > 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보.
    - 메모리 보호를 위해 사용하는 [경계 레지스터(Boundary register)](https://wordrow.kr/%EC%9D%98%EB%AF%B8/%EA%B2%BD%EA%B3%84%20%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0/)값 등이 저장된다.
    - 세그멘테이션 테이블(Segmentation Table)과 페이지 테이블(Page Table) 등의 정보도 저장한다.
8. 할당된 자원 정보
    > 프로세스를 실행하기 위해 사용하는 입출력 자원이나 오픈 파일 등에 대한 정보.
    - 어떠한 프로세스가 특정 하드디스크에 저장된 파일을 접근해야 된다거나, 음악을 재생하기 위해 사운드카드에 접근하고 있다면, 파일이나 사운 카드에 대한 정보가 필요한데, 이런 정보를 PCB에 저장한다.
9. Accounting Information(계정 정보)
    > CPU 할당 시간, CPU 사용시간, 프로세스 진행 시간 등을 저장.
    - 예) 작업 관리자에 나오는 CPU, 프로그램 정보
10. 부모 프로세스 구분자와 자식 프로세스 구분자
    > Parent Process(부모 프로세스) 를 가리키는 PPID와 Child Process(자식 프로세스)를 가리키는 CPID 정보도 저장된다.

# Context Switching(문맥 교환)
### 한 문장으로
  > 현재 CPU를 차지하고 있던 프로세스의 CPU 제어권을 다른 프로세스에게 넘기는 작업.
  
## 기본개념
  - 문맥 교환이란, CPU 전환이 일어날 때 기존 프로세스의 상태를 저장하고 새 프로세스의 상태를 읽어오는 것이다.
  - 문맥 교환이 발생하면 두 PCB의 내용이 변경된다.
  - 실행 상태에서 나가는 PCB는 지금까지의 작업 내용을 저장하고, 실행 상태로 새롭게 들어오는 PCB는 CPU가 다시 세팅한다.
  - 한 번 발생할 때마다 상당한 오버헤드가 발생.

## 문맥 교환의 역할
  > 여러 개의 프로세스가 하나의 CPU를 공유할 수 있도록 한다. 즉, 운영체제가 멀티태스킹을 할 수 있도록 도와준다.

## 문맥 교환의 절차
![Screen Shot 2021-09-30 at 10 03 35 PM](https://user-images.githubusercontent.com/33091784/135460329-052c00ad-fe59-4e52-ac14-fab9b5379461.png)

## 문맥 교환이 일어나는 경우
  - 일반적으로 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생
  - 인터럽트가 걸렸을 때도 발생
    - 어떤 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 한다면 이는 경계 레지스터의 범위를 벗어나는 것이다.
    - 이때, 인터럽트가 발생하여 현재 실행 중인 프로세스의 제어 블록을 저장한 후 인터럽트 관리 프로세스를 실행 상태로 만든다.
    - 인터럽트 관리 프로세스는 메모리 범위를 넘어선 프로세스를 강제로 종료하고 인터럽트 처리를 마치는데, 이와 같이 인터럽트 처리를 할 때도 문맥 교환이 일어난다.

## 여기서 질문!
  - 문맥 교환 시에 오버헤드가 왜 발생할까??
  - 문맥 교환은 자주 일어날수록 좋을까요? 뜸하게 일어날수록 좋을까요?
  - 인터럽트가 걸려서 문맥 교환이 발생하는 예는??

## 참고
- 쉽게 배우는 운영체제(Introduction to Operating Systems)
- https://en.wikipedia.org/wiki/Process_control_block
- https://jhnyang.tistory.com/33
- https://kosaf04pyh.tistory.com/195
- https://en.wikipedia.org/wiki/Context_switch
  


